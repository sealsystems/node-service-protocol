"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Flaschenpost = exports.flaschenpost = void 0;
const lodash_1 = require("lodash");
const Configuration_1 = require("./Configuration");
const find_root_1 = __importDefault(require("find-root"));
const fs_1 = __importDefault(require("fs"));
const getLogEntryIdGenerator_1 = require("./getLogEntryIdGenerator");
const isLogLevel_1 = require("./isLogLevel");
const Logger_1 = require("./Logger");
const os_1 = __importDefault(require("os"));
const processenv_1 = require("processenv");
const readPackageJson_1 = require("./readPackageJson");
const stack_trace_1 = __importDefault(require("stack-trace"));
const formatters_1 = require("./formatters");
class Flaschenpost {
    constructor() {
        const stringifiedDebugModuleFilter = processenv_1.processenv('LOG_DEBUG_MODULE_FILTER', '');
        if (typeof stringifiedDebugModuleFilter !== 'string') {
            throw new Error('Debug module filter invalid.');
        }
        const debugModuleFilter = stringifiedDebugModuleFilter.
            split(',').
            filter((item) => Boolean(item));
        let formatter = process.stdout.isTTY ? formatters_1.asHumanReadable : formatters_1.asJson;
        const formatterOverride = processenv_1.processenv('LOG_FORMATTER');
        if (formatterOverride) {
            formatter = formatterOverride === 'human' ? formatters_1.asHumanReadable : formatters_1.asJson;
        }
        const logLevel = processenv_1.processenv('LOG_LEVEL', 'info');
        if (!isLogLevel_1.isLogLevel(logLevel)) {
            throw new Error(`Log level '${logLevel}' unknown.`);
        }
        const highestEnabledLogLevel = logLevel;
        const hostname = os_1.default.hostname();
        const logEntryIdGenerator = getLogEntryIdGenerator_1.getLogEntryIdGenerator();
        this.configuration = new Configuration_1.Configuration(debugModuleFilter, formatter, highestEnabledLogLevel, hostname, logEntryIdGenerator);
    }
    configure(configuration) {
        this.configuration = configuration;
    }
    getConfiguration() {
        return lodash_1.cloneDeep(this.configuration);
    }
    // When creating a logger, there are basically two options: Most probably you
    // get a logger for an existing file, but from time to time you may want to
    // get a logger for a virtual file. In this case you not only need to override
    // the source path, but also the appropriate package.json definition, i.e. if
    // you want to use a virtual file name, you must additionally provide a
    // package.json override. If you refer to an existing file, you can skip this.
    getLogger(sourcePathOverride, packageJsonOverrideForVirtualSourcePaths) {
        let sourcePath;
        let packageJson;
        if (sourcePathOverride) {
            if (!packageJsonOverrideForVirtualSourcePaths) {
                /* eslint-disable no-sync */
                fs_1.default.accessSync(sourcePathOverride, fs_1.default.constants.R_OK);
                /* eslint-enable no-sync */
            }
            sourcePath = sourcePathOverride;
        }
        else {
            // Do not move this line to outside the if statement as default value, as
            // getting the stack trace is pretty slow, so it should be kept here for
            // performance reasons.
            sourcePath = stack_trace_1.default.get()[1].getFileName();
        }
        if (packageJsonOverrideForVirtualSourcePaths) {
            packageJson = packageJsonOverrideForVirtualSourcePaths;
        }
        else {
            const modulePath = find_root_1.default(sourcePath);
            packageJson = readPackageJson_1.readPackageJson(modulePath);
        }
        return new Logger_1.Logger(this.configuration, sourcePath, packageJson);
    }
}
exports.Flaschenpost = Flaschenpost;
const flaschenpost = new Flaschenpost();
exports.flaschenpost = flaschenpost;
